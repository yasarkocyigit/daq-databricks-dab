"""
Shared fixtures for Lakebase Autoscaling integration tests.

Strategy:
  - If an existing project with prefix "lb-auto-test-" exists, reuse it.
  - Otherwise, create a new project and wait for it to become READY.
  - The session-scoped project is NOT deleted at teardown so it can be
    reused across runs (manual cleanup is expected).
  - Branch / endpoint cleanup helpers are provided for tests that create
    child resources.
"""

import logging
import os
import time
import uuid

import pytest

from databricks_tools_core.lakebase_autoscale import (
    create_project,
    delete_branch,
    delete_endpoint,
    delete_project,
    get_project,
    list_branches,
    list_projects,
)

logger = logging.getLogger(__name__)

TEST_PREFIX = "lb-auto-test-"
PROJECT_READY_TIMEOUT = 600  # seconds


def _wait_for_project_ready(project_name: str, timeout: int = PROJECT_READY_TIMEOUT):
    """Poll until the project reaches a READY state."""
    deadline = time.time() + timeout
    while time.time() < deadline:
        proj = get_project(project_name)
        state = proj.get("state", "")
        if "READY" in str(state).upper():
            logger.info(f"Project {project_name} is READY")
            return proj
        logger.info(f"Project {project_name} state={state}, waiting...")
        time.sleep(15)
    raise TimeoutError(f"Project {project_name} did not become READY within {timeout}s")


@pytest.fixture(scope="session")
def lakebase_project_name():
    """
    Return a reusable test project name.

    Looks for an existing project with prefix ``lb-auto-test-``.
    If none exists, creates one and waits for it to be ready.
    """
    projects = list_projects()
    for p in projects:
        name = p.get("name", "")
        project_id = name.split("/")[-1] if "/" in name else name
        if project_id.startswith(TEST_PREFIX):
            state = p.get("state", "")
            if "READY" in str(state).upper() or state == "":
                logger.info(f"Reusing existing project: {name}")
                return name

    # No reusable project â€“ create one
    suffix = uuid.uuid4().hex[:8]
    project_id = f"{TEST_PREFIX}{suffix}"
    logger.info(f"Creating new test project: {project_id}")

    result = create_project(
        project_id=project_id,
        display_name=f"Integration Test {suffix}",
    )
    project_name = result["name"]
    _wait_for_project_ready(project_name)
    return project_name


@pytest.fixture(scope="session")
def lakebase_default_branch(lakebase_project_name: str):
    """
    Return the default branch name for the test project.

    The default branch is created automatically with the project.
    Its ID is auto-generated by the service.
    """
    branches = list_branches(lakebase_project_name)
    default_branches = [b for b in branches if b.get("is_default") is True]
    if default_branches:
        branch_name = default_branches[0]["name"]
    else:
        branch_name = branches[0]["name"]

    logger.info(f"Default branch: {branch_name}")
    return branch_name


@pytest.fixture(scope="session")
def unique_name():
    """Return a short unique suffix for naming test resources."""
    return uuid.uuid4().hex[:6]


@pytest.fixture
def cleanup_branches():
    """Fixture that returns a helper to register branches for cleanup."""
    branches_to_delete: list[str] = []

    def _register(branch_name: str):
        branches_to_delete.append(branch_name)

    yield _register

    for name in reversed(branches_to_delete):
        try:
            delete_branch(name)
            logger.info(f"Cleaned up branch: {name}")
        except Exception as exc:
            logger.warning(f"Branch cleanup failed for {name}: {exc}")


@pytest.fixture
def cleanup_projects():
    """Fixture that returns a helper to register projects for cleanup."""
    projects_to_delete: list[str] = []

    def _register(project_name: str):
        projects_to_delete.append(project_name)

    yield _register

    for name in reversed(projects_to_delete):
        try:
            delete_project(name)
            logger.info(f"Cleaned up project: {name}")
        except Exception as exc:
            logger.warning(f"Project cleanup failed for {name}: {exc}")


@pytest.fixture
def cleanup_endpoints():
    """Fixture that returns a helper to register endpoints for cleanup."""
    endpoints_to_delete: list[str] = []

    def _register(endpoint_name: str):
        endpoints_to_delete.append(endpoint_name)

    yield _register

    for name in reversed(endpoints_to_delete):
        try:
            delete_endpoint(name)
            logger.info(f"Cleaned up endpoint: {name}")
        except Exception as exc:
            logger.warning(f"Endpoint cleanup failed for {name}: {exc}")
